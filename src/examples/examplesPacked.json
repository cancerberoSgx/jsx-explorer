{"src/examples/toPack/dangerouslySetInnerHTML.tsx":{"isBinary":false,"fileName":"src/examples/toPack/dangerouslySetInnerHTML.tsx","originalFileName":"src/examples/toPack/dangerouslySetInnerHTML.tsx","content":"import * as React from 'react'\n\nfunction sample() {\n  const name = 'Rambo',\n    suffix = 'Mister'\n  return (\n    <div className=\"simple2\">\n      Hello\n      <span dangerouslySetInnerHTML={{__html: `\\n<strong>${suffix}</strong>\\n<em className=\"name\">${name}</em>\\n`}} />!\n    </div>\n  )\n}\n"},"src/examples/toPack/aLotOfTags.tsx":{"isBinary":false,"fileName":"src/examples/toPack/aLotOfTags.tsx","originalFileName":"src/examples/toPack/aLotOfTags.tsx","content":"import * as React from 'react'\n\nfunction test() {\n  const people = [{name: 'Sebastián', age: 12}, {name: 'Laura', age: 22}]\n  const showContactForm = true\n  return (\n    <div className=\"people\">\n      <h1>People</h1>\n\n      <p>\n        This example contains lots of combinations of <i>JSX</i> so it's ideal to test\n        <a href=\"https://cancerberosgx.github.io/jsx-alone/jsx-explorer/\">JSX Syntax Highlight</a>\n      </p>\n\n      <hr className=\"hr\" />\n\n      <ul>\n        {people.map((p, i) => (\n          <li data-id={`person_${i}`}>\n            <strong {...p} className=\"name\">\n              {p.name}\n            </strong>{' '}\n            is\n            <span {...p} className=\"age\">\n              {p.age}\n            </span>{' '}\n            years old\n            <div>\n              very\n              <div>\n                nested\n                <p>\n                  {[0, 1].map(n => (\n                    <div style={{...{...{margin: 0}}}}>test</div>\n                  ))}\n                </p>\n              </div>\n            </div>\n          </li>\n        ))}\n      </ul>\n\n      <hr />\n      <br />\n\n      {showContactForm && (\n        <article>\n          <h2 {...{id: 'contactFormTitle'}}>Contact</h2>\n\n          <label>\n            Your name?\n            <input onChange={e => console.log('changed')} />\n          </label>\n\n          <button className=\"button is-primary\" onClick={e => alert(`submitted \\${people.length} persons`)}>\n            Submit\n          </button>\n        </article>\n      )}\n    </div>\n  )\n}\n"},"src/examples/toPack/exampleConditionals.tsx":{"isBinary":false,"fileName":"src/examples/toPack/exampleConditionals.tsx","originalFileName":"src/examples/toPack/exampleConditionals.tsx","content":"import * as React from 'react'\n\nfunction conditionals() {\n  function makeNode(p = 0.5): Node | undefined {\n    return Math.random() < p\n      ? ({\n          getKindName() {\n            return unique('Kind')\n          },\n          getType() {\n            return makeNode()\n          },\n          getText() {\n            return unique('text')\n          },\n          getChildren() {\n            return [makeNode() || makeNode() || makeNode()].filter(e => e)\n          },\n        } as Node)\n      : undefined\n  }\n\n  let _unique: number = 0\n  function unique(prefix: string = '_'): string {\n    return prefix + '_' + _unique++\n  }\n\n  function RenderNode(props: {\n    node: Node\n    mode: string\n    onShowDetailsOf(p: string, node: Node): void\n    showDetailsOf: string\n    path: string\n    collapsed?: boolean\n  }) {\n    const {node, mode, onShowDetailsOf, path, collapsed, showDetailsOf} = props\n    const children = mode === 'forEachChild' ? node.getChildren().reverse() : node.getChildren()\n\n    return (\n      <div className=\"content\" data-key={path}>\n        <strong>{node.getKindName()}</strong>\n\n        <button\n          className=\"button is-small\"\n          onClick={e => {\n            onShowDetailsOf(path, node)\n          }}>\n          !\n        </button>\n\n        <button\n          className=\"button is-small\"\n          onClick={e => {\n            // this.updateProps({ collapsed: !collapsed })\n          }}>\n          {collapsed ? '+' : '-'}\n        </button>\n\n        {!collapsed && showDetailsOf === path && (\n          <div className=\"nodeInfo\">\n            <strong>Text</strong>: <code>\"{node && node.getText()}...\"</code>\n            <br />\n            <strong>Type</strong>: <code>{node.getType() && node.getType()!.getText()}</code>\n          </div>\n        )}\n\n        {!collapsed && (\n          <ul>\n            {children\n              .filter(c => c)\n              .map((c, i) => (\n                <li>\n                  <RenderNode\n                    node={c}\n                    path={path + i}\n                    onShowDetailsOf={onShowDetailsOf}\n                    mode={mode}\n                    showDetailsOf={showDetailsOf}\n                  />\n                </li>\n              ))}\n          </ul>\n        )}\n      </div>\n    )\n  }\n\n  const props = {\n    node: makeNode(11)!,\n    mode: 'getChildren',\n    onShowDetailsOf(p: string, node: Node) {},\n    collapsed: false,\n    showDetailsOf: '/00',\n    path: '/00',\n  }\n\n  return <RenderNode {...props} />\n}\n\ninterface Node {\n  getKindName(): string\n  getType(): Node | undefined\n  getText(): string\n  getChildren(): Node[]\n}\n"},"src/examples/toPack/exampleLotsOfComponents.tsx":{"isBinary":false,"fileName":"src/examples/toPack/exampleLotsOfComponents.tsx","originalFileName":"src/examples/toPack/exampleLotsOfComponents.tsx","content":"/*DONT CHANGE THIS FIRST LINE*/ import * as React from 'react'\ndeclare var PERSON_COUNT: number\ndeclare var CONTACT_COUNT: number\ndeclare var ADDRESS_COUNT: number\ndeclare class ElementClass<P = any> extends React.Component<P, any> {}\n\nfunction exampleLotsOfComponents() {\n  interface StyleProps {\n    classes: {[name: string]: ClassRule}\n    renderConfig?: {indent?: number}\n  }\n  class Style extends ElementClass<StyleProps> {\n    private indent(n: number): string {\n      return this.props.renderConfig && this.props.renderConfig.indent\n        ? new Array(n * 2)\n            .fill(0)\n            .map(j => ' ')\n            .join('')\n        : ''\n    }\n    private fixProperty(s: string): string {\n      let t\n      while ((t = /([A-Z])/.exec(s))) {\n        s = s.substring(0, t.index) + '-' + t[1].toLowerCase() + s.substring(t.index + 1, s.length)\n      }\n      return s\n    }\n    render() {\n      const {classes} = this.props\n      const __html = Object.keys(classes)\n        .map(\n          c =>\n            `${this.indent(1)}.${c}${\n              classes[c] && classes[c].selectorPostfix ? classes[c].selectorPostfix : ''\n            } {${Object.keys(classes[c])\n              .filter(p => p !== 'selectorPostfix')\n              .map(p => `${this.indent(2)}${this.fixProperty(p)}: ${classes[c][p as any]};`)\n              .join(``)}\n}`,\n        )\n        .join('\\n')\n      return <style dangerouslySetInnerHTML={{__html}} />\n    }\n    static build<T extends {[k: string]: ClassRule}>(styles: T): {styles: T; classes: {[k in keyof T]: k}} {\n      const classes: any = {}\n      Object.keys(styles).forEach(k => {\n        classes[k] = k\n      })\n      return {\n        styles,\n        classes,\n      }\n    }\n  }\n  type ClassRule = Partial<CSSStyleDeclaration> & {selectorPostfix?: string}\n\n  // Auxiliary <If> component\n\n  interface IfProps<T> {\n    c: any\n    p?: T\n    children: (...args: NotFalsy<T>[]) => JSX.Element | (JSX.Element[]) | null\n  }\n  function If<T extends any = any>(props: IfProps<T>) {\n    const f = Array.isArray(props.children) ? props.children[0] : props.children\n    if (isNotFalsy(props.c)) {\n      return f.apply(null, [...(props.p ? [props.p] : []), props.c])\n    } else {\n      return null\n    }\n  }\n  type NotFalsy<C = any> = Exclude<C, Falsy>\n  type Falsy = null | '' | undefined | false\n  function isNotFalsy<T>(a: T): a is NotFalsy<T> {\n    return !!a\n  }\n\n  // THE APP\n\n  // THE APP TyPES\n\n  interface ContactModel {\n    addresses: AddressModel[]\n    phone: string\n  }\n  interface AddressModel {\n    name: string\n    number: number\n  }\n  interface PersonModel {\n    name: string\n    age: number\n    contacts: ContactModel[]\n  }\n\n  // THE APP Styles\n\n  const value: ClassRule = {\n    fontWeight: 'bold',\n  }\n  const name: ClassRule = {\n    ...value,\n    border: '2px sold pink',\n  }\n  const number: ClassRule = {\n    ...value,\n    textTransform: 'italic',\n  }\n  const {styles, classes} = Style.build({value, name, number})\n\n  // The APP components\n\n  const Name = (props: {name: string}) => (\n    <If c={props.name !== 'Seba'}>\n      {() => (\n        <span className={classes.name} data-test=\"name\">\n          {props.name}\n        </span>\n      )}\n    </If>\n  )\n  const Age = (props: {age: number}) => (\n    <If c={props.age !== 5}>\n      {() => (\n        <span className={classes.number} data-test=\"age\">\n          {props.age}\n        </span>\n      )}\n    </If>\n  )\n  class Person extends ElementClass<PersonModel> {\n    render() {\n      return (\n        <div data-test=\"person\" className=\"person\">\n          <Name name={this.props.name} />\n          <Age age={this.props.age} />\n          {this.props.contacts.map(a => (\n            <Contact addresses={a.addresses} phone={a.phone} />\n          ))}\n        </div>\n      )\n    }\n  }\n\n  const Address = (props: AddressModel) => (\n    <span data-test=\"address\">\n      <span className={classes.name} data-test=\"address-name\">\n        {props.name}\n      </span>{' '}\n      number:{' '}\n      <span className={classes.number} data-test=\"address-number\">\n        {props.number}\n      </span>\n    </span>\n  )\n\n  class Contact extends ElementClass<ContactModel> {\n    render() {\n      return (\n        <div data-test=\"contact\">\n          <If c={this.props.addresses.length} p={this.props.addresses}>\n            {addresses => addresses.map(ad => <Address name={ad.name} number={ad.number} />)}\n          </If>\n        </div>\n      )\n    }\n  }\n\n  class App extends ElementClass<AppProps> {\n    render() {\n      return (\n        <div>\n          {this.props.people.map(p => (\n            <Person {...p} />\n          ))}\n        </div>\n      )\n    }\n  }\n\n  // MAIN\n\n  function makeModel(\n    personCount = PERSON_COUNT || 10,\n    contactCount = CONTACT_COUNT || 5,\n    addressCount = ADDRESS_COUNT || 3,\n  ): PersonModel[] {\n    return range(personCount).map(i => ({\n      name: name(),\n      age: int(2, 6),\n      contacts: range(contactCount!).map(j => ({\n        addresses: range(addressCount!).map(j => ({\n          name: name(),\n          number: int(10000, 100000),\n        })),\n        phone: int(1000000, 10000000) + '',\n      })),\n    }))\n    function range(i: number) {\n      return new Array(i).fill(0)\n    }\n    function int(a: number, b: number) {\n      return Math.floor(Math.random() * b) + a\n    }\n    function item<T>(a: T[]): T {\n      return a[int(0, a.length)]\n    }\n    function name() {\n      return item(['Seba', 'Laura', 'Andres', 'Zapicán', 'Montezuma'])\n    }\n  }\n\n  return <App people={makeModel()} />\n}\n\n// THE APP TYPES\n\ninterface Contact {\n  addresses: Address[]\n  phone: string\n}\ninterface Address {\n  name: string\n  number: number\n}\ninterface Person {\n  name: string\n  age: number\n  contacts: Contact[]\n}\ninterface AppProps {\n  people: Person[]\n}\n"},"src/examples/toPack/exampleSimple1.tsx":{"isBinary":false,"fileName":"src/examples/toPack/exampleSimple1.tsx","originalFileName":"src/examples/toPack/exampleSimple1.tsx","content":"import * as React from 'react'\n\nfunction simple1() {\n  const people = [{name: 'Sebastián', age: 12}, {name: 'Laura', age: 22}]\n  const t0 = Date.now()\n  return (\n    <div className=\"people\">\n      <h1>People</h1>\n      <ul>\n        {people.map(p => (\n          <li>\n            <strong className=\"name\">{p.name}</strong> is <span className=\"age\">{p.age}</span> years old\n          </li>\n        ))}\n      </ul>\n      <p>\n        Listed {people.length} persons in {Date.now() - t0 + ''} milliseconds.{' '}\n      </p>\n      <button className=\"button is-primary\" onClick={e => alert(`submitted \\${people.length} persons`)}>\n        Submit\n      </button>\n    </div>\n  )\n}\n"},"src/examples/toPack/renderInCustomImpls.tsx":{"isBinary":false,"fileName":"src/examples/toPack/renderInCustomImpls.tsx","originalFileName":"src/examples/toPack/renderInCustomImpls.tsx","content":"/*DONT CHANGE THIS FIRST LINE*/ import {JSXAloneJsonImpl as JSXAloneJson} from 'jsx-alone-core'\nimport {JSXAlone as JSXAloneDom} from 'jsx-alone-dom'\nimport * as React from 'react'\nimport {JSXAlone as JSXAloneString} from 'jsx-alone-string'\nconst WORD_COUNT = 4,\n  PEOPLE_COUNT = 5\n\nfunction test() {\n  // This test renders JS using different implementations altogether. This is\n  // mostly a hack and you don't do this in the real world, it's just a demo.\n\n  // The way of forcing a custom implementation in this context is creating the\n  // JSXAlone variable and then declare JSX inside an inner function. Returning a\n  // string instead of JSX will result in an element with the string as innerHTML\n\n  let JSXAlone = JSXAloneJson as any\n\n  function render<T = any>(impl: 'json' | 'string' | 'dom', f: () => JSX.Element): T {\n    JSXAlone = impl === 'dom' ? JSXAloneDom : impl === 'string' ? JSXAloneString : JSXAloneJson\n    const jsx = f()\n    const result = JSXAlone.render(jsx)\n    return result as any\n  }\n\n  const arr = (a: number = number(10, 20), b = a) => new Array(Math.trunc(number(a, b) || 1)).fill(0)\n  const string = (length: number = number(10, 20)) =>\n    arr(length / 5 + 1)\n      .map(i =>\n        Math.random()\n          .toString(36)\n          .substr(2, 5),\n      )\n      .reduce((a, b) => a.concat(b))\n  const words = (\n    wordCount = number(10, 20),\n    wordLength = number(5, 10),\n    wordCountB = wordCount,\n    wordLengthB = wordLength,\n  ) => arr(wordCount, wordCountB).map(i => string(number(wordLength, wordLengthB)))\n  const number = (a = 10, b = a) => Math.floor(Math.random() * b) + (a === b ? 0 : a)\n\n  const C = (props: {label: string}) => (\n    <div className=\"content\">\n      <h2>{props.label}</h2>\n      <div>\n        test {string(3)} \"{words(2, 5, 4, 10)}\"\n      </div>\n      <ul>\n        {arr(PEOPLE_COUNT, PEOPLE_COUNT * 2).map(i => (\n          <li>\n            Name: <strong> \"{words(2, 2, 4, 10).join(' ')}\"</strong>. Age: \"{number(100)}\". Answer:{' '}\n            <i>\"{words(WORD_COUNT, 2, WORD_COUNT * 2, 14).join('   ')}\"</i>\n          </li>\n        ))}\n      </ul>\n    </div>\n  )\n\n  let t0 = Date.now()\n  const s = render('string', () => <C label=\"I once was a string, because JSXAlone string impl was used\" />)\n  const stringTime = Date.now() - t0\n  t0 = Date.now()\n  const json = render('json', () => <C label=\"I wasn't a string nor a DOM element since they used the json impl\" />)\n  const jsonTime = Date.now() - t0\n  t0 = Date.now()\n  const el = render<HTMLElement>('dom', () => (\n    <C label={'I was born being a DOM element, this is the proof: ' + JSON.stringify(self.performance.toJSON())} />\n  ))\n  const domTime = Date.now() - t0\n\n  // At this point we need to restore the original implementation in order to\n  // declare Elements that the test environment expect (which is the json one)\n  JSXAlone = JSXAloneJson as any\n\n  return (\n    <div className=\"content\">\n      <h1>Rendering different implementations</h1>\n      <p>\n        Well, here we have three components that were rendered using the three implementations, in this same page.\n        Timings:{' '}\n      </p>\n      <ul>\n        <li>String: {stringTime}ms.</li>\n        <li>DOM: {domTime}ms.</li>\n        <li>JSON: {jsonTime}ms.</li>\n      </ul>\n      <ul>\n        <li style={{height: '400px', overflow: 'scroll'}}>\n          <h3>String</h3> {s.length + 'bytes'} - we use dangerouslySetInnerHTML to render the string output here.\n          <div>{s}</div>\n        </li>\n        <li style={{height: '400px', overflow: 'scroll'}}>\n          <h3>DOM</h3> {el.outerHTML.length + 'bytes'} -DOM impl currently don't work because examples run in a\n          webworker with has no DOM:\n          <div>{el.outerHTML}</div>\n        </li>\n        <li style={{height: '400px', overflow: 'scroll'}}>\n          <h3>JSON</h3>: we use JSON.stringify() to print the JSON output:\n          <pre>{JSON.stringify(json)}</pre>w\n        </li>\n      </ul>\n    </div>\n  )\n}\n"},"src/examples/toPack/renderInCustomImplsSimple.tsx":{"isBinary":false,"fileName":"src/examples/toPack/renderInCustomImplsSimple.tsx","originalFileName":"src/examples/toPack/renderInCustomImplsSimple.tsx","content":"/*DONT CHANGE THIS FIRST LINE*/ import * as React from 'react'\nimport {\n  JSXAloneJsonImpl as JSXAlone,\n  JSXAloneJsonImpl as JSXAloneJson,\n  jsonImplOutputElAsHtml,\n  JsonImplOutputEl,\n} from 'jsx-alone-core'\nimport {JSXAlone as JSXAloneDom} from 'jsx-alone-dom'\nimport {JSXAlone as JSXAloneString} from 'jsx-alone-string'\n\nfunction test() {\n  // This test renders JS using different implementations altogether. This is\n  // mostly a hack and you don't do this in the real world, it's just a demo.\n\n  // The way of forcing a custom implementation in this context is creating the\n  // JSXAlone variable and then declare JSX inside an inner function.\n\n  let JSXAlone = JSXAloneString\n  const s: string = (() => {\n    const el = <div className=\"string\">Hello</div>\n    return JSXAloneString.render(el)\n  })()\n\n  // At this point we need to restore the original implementation in order to\n  // declare Elements that the test environment expect (which is the json one)\n  JSXAlone = JSXAloneJson as any\n  return <pre>{s}</pre>\n}\n"}}